<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="description"><meta name="keyword"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>GARY.SHEN</title><link rel="shortcut icon" href="/images/avatar.png" type="image/x-icon"><link href="/styles/site.css" rel="stylesheet"></head><body><header class="container" id="header"><div class="header"><div class="header-left"><div class="avatar"><img src="/images/avatar.png"></div><div class="author"><div class="author-name"><a href="/">GARY.SHEN</a></div><div class="about-me">Halo~</div></div></div><div class="header-right"><ul class="navigation"><li><a href="/archives">归档</a></li></ul></div><div class="about-me-mask"><div class="about-me-wrap"><div class="about-me__header"><div class="avatar"><img src="/images/avatar.png"></div></div><ul class="socials"><li class="social-item"><span class="label"><img src="/images/socials/github.svg" alt="https://github.com/baiyewww"></span><a href="https://github.com/baiyewww" target="_blank" title="https://github.com/baiyewww">https://github.com/baiyewww</a></li><li class="social-item"><span class="label"><img src="/images/socials/email.svg" alt="844624471@qq.com"></span><span>844624471@qq.com</span></li><li class="social-item"><span class="label"><img src="/images/socials/wechat.svg" alt="gunzi666"></span><span>gunzi666</span></li></ul></div></div></div></header><div class="container home"><section class="article"><a class="title" href="/2019/03/02/hello-world/">考研复试复习</a><div class="content excerpt"><p>==<strong>C和C++和java的区别？</strong>==</p>
<p>①c是面向过程的语言，cpp和java是面向对象的语言。这是他们最本质的区别。</p>
<p>②C和cpp是直接编译运行，java是在虚拟机中运行的。</p>
<p>③指针的方面，c和c++可以直接用指针来访问内存，java没有指针。</p>
<p><strong>==C++里的结构体和类的区别:==</strong></p>
<p>结构体默认访问权限全是public</p>
<p>类访问权限是public 、private、protected，默认访问权限是private</p>
<p>==<strong>Stl含义：</strong>==</p>
<p>标准模板库Standard Template Library是容器和算法的集合</p>
<p>eg：Vector(向量)、stack（栈）、set（集合）、queue（队列）、map（哈希表）</p>
<p>==<strong>指针和引用的区别？</strong>==</p>
<p>①指针是存储变量地址的变量。</p>
<p>②引用在函数传参的时候用到。引用本身也是地址，在传递的时候不是值，传的是地址。</p>
<p>==<strong>面向对象的三大特性</strong>==</p>
<p>封装：是把成员变量和成员函数封装进一个类并赋予它一些权限。</p>
<p>继承：首先要有一个基类，然后派生类继承基类，派生类能继承基类的成员变量和成员函数。</p>
<p>多态：多态就是同一个接口，使用不同的实例而执行不同操作。简单的说，一个接口，多种实现方式。Eg：函数重载。</p>
<p>==<strong>编译一个程序内存分为哪两部分？</strong>==</p>
<p>堆内存和栈内存。</p>
<p>==<strong>关键字和标识符的区别？</strong>==</p>
<p>标识符是变量名。比如a、b、c…</p>
<p>关键字是new、delete、int、break…</p>
<p>==<strong>运算符重载和函数重载的区别？</strong>==</p>
<p>运算符本身也是函数，运算符包涵单目和双目运算符。<br>如果运算符重载的话需要参数数量的问题。</p>
<p><strong>==重载和重写？==</strong></p>
<p>++重写（override覆盖）++：如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写。</p>
<p>++重载：++如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型或有不同的参数次序，则称为方法的重载</p>
<p>方法的重写(Overriding)和重载(Overloading)是Java多态性的不同表现。 </p>
<p>重写(Overriding)是父类与子类之间多态性的一种表现，而重载(Overloading)是一个类中多态性的一种表现。</p>
<p><strong>==全局变量（global variable）和局部变量（local variable）的区别？==</strong></p>
<ol>
<li>作用域不同：全局变量的作用域为整个程序，而局部变量的作用域为当前函数或循环等</li>
<li>内存存储方式不同：全局变量存储在堆区中，局部变量存储在栈区</li>
<li>生命期不同：全局变量的生命期和主程序一样，随程序的销毁而销毁，局部变量在函数内部或循环内部，随函数的退出或循环退出就不存在了</li>
<li>使用方式不同：全局变量在声明后程序的各个部分都可以用到，但是局部变量只能在局部使用。函数内部会优先使用局部变量再使用全局变量</li>
</ol>
<p><strong>==构造函数和析构函数是干什么的？==</strong></p>
<p>构造：对象实例化的时候自动运行的函数，进行对象初始化。</p>
<p>析构：撤销对象的时候会自动运行的函数，可以是释放对象分配的内存空间。</p>
<p>==<strong>Static:</strong>==</p>
<p>它是一个声明静态变量的关键字。静态变量就是空间里独立开放的一块静态空间去保存这个变量的值，如果定义了一个静态类变量，那么所有的实例都可以共享这个类变量。</p>
<p>class 里的static，比如我有个类A 里面有个static int＝5，实例一个a，令a.这个值＝10，再实例一个b，那么b.这个值是多少呢？是10。因为单独开辟了一个空间，不管多少个实例都是指向那里，所以这个可以用来统计实例个数，也可以控制实例数量。比如每实例一个，可以让一个静态变量++或者–</p>
<p>==<strong>Const：</strong>==</p>
<p>const 修饰符：用于定义符号常量。用关键字 const 修饰的标识符称为符号常量。常量就是不能修改值的变量，而且必须有一个初始的值。</p>
<p>==<strong>预处理程序</strong>==</p>
<p>C＋＋的预处理程序不是 C＋＋编译程序的一部分，它负责在编译程序的其他部分之前分析处理预处理语句，为与一般的 C＋＋语句区别，所有预处理语句都以位于行首的符号“＃”开始，作用是把所有出现的、被定义的名字全部替换成对应的“字符序列”。</p>
<p>预处理语句有三种：宏定义、文件包含（也成嵌入指令）和条件编译<br>文件包含是指一个程序把另一个指定文件的内容包含进来，书写时可以使用引号也可以使用尖括号，前者引用自己定义的包含文件，如：＃include “E:\prog\myfile.h” ,后者引用系统提供的包含文件，如标准输入输出是定义，在标准库 iostream 中的，引用时要包括以下两条语句：<br>＃include <iostream> //包含头文件<br>using namespace std； //使用命名空间</iostream></p>
<p>==<strong>面向过程和面向对象的区别：</strong>==</p>
<p>面向过程主要依赖于三大结构：顺序结构、选择结构、循环结构，世界上所有的程序都可以用面向过程去实现。</p>
<p>面向对象就是在面向过程的基础上加入了类和对象的概念。面向对象更适合人类的思想，更适合于编程。</p>
<p>==<strong>认识 C＋＋面向过程编译的特点</strong>==</p>
<p>++一、使用函数重载++</p>
<p>函数重载：C＋＋允许为同一个函数定义几个版本，从而使一个函数名具有多种功能，<br>这称为函数重载。<br>假设有一个函数 max，分别具有以下函数原型：</p>
<p>int max（int，int）； //2 个整型参数的函数原型</p>
<p>int max（int，int，int）；//3个整型参数的函数原型</p>
<p>只要分别为不同参数的max编制相应的函数体，就可以实现各自的功能。</p>
<p>++二、新的基本数据类型及其注意事项++</p>
<p>1、void 是无类型标识符，只能声明函数的返回值类型，不能声明变量。</p>
<p>2、C＋＋还比 C 多了 bool（布尔）型。</p>
<p>3、地址运算符“&amp;”用来取对象存储的首地址，对于数组，则数组名就是数组的<br>首地址。<br>如：int x＝56；定义 x，VC＋＋6.0 使用 4 个字节存储对象 56，假设存放的内<br>存首地址用十六进制表示为 006AFDEC，则语句 cout &lt;&lt;&amp;x；自动使用十六进制输<br>出存储的首地址 006AFDEC。</p>
<p>4、C＋＋与 C 一样，也使用转义序列。如：’\0’表示 ASCII 码值为零的空字符<br>（NULL），’\101’表示字符 A。</p>
<p>++三、动态分配内存++</p>
<p>1、在使用指针时，如果不使用对象地址初始化指针，可以自己给它分配地址。<br>对于只存储一个基本类型数据的指针，申请方式如下：</p>
<p>new 类型名[size]//申请可以存储size个该数据类型的对象</p>
<p>不再使用时，必须使用delete指针名；来释放已经申请的存储空间。</p>
<p>如：</p>
<p>……</p>
<p>double *p； //声明 double 型指针</p>
<p>p＝new double[3] //分配3个double型数据的存储空间<br>……</p>
<p>delete p； //释放已申请的存储空间</p>
<p>……</p>
<p>2、C 必须在可执行语句之前集中声明变量，而 C＋＋可以在使用对象时再声明或<br>定义。</p>
<p>++四、引用++</p>
<p>1、引用：就是为现有的对象起个别名，别名的地址与引用对象的地址是一样的。所谓“引用”，就是将一个新标识符和一块已经存在的存储区域相关联。因此，使用引用时没有分配新的存储区域，它本身不是新的数据类型。可以通过修改引用来修改原对象，但是不能有空引用，在程序中必须确保引用是和一块正确的存储区域关联。</p>
<p>引用的声明方式为： 数据类型 &amp; 别名＝对象名； 注意对象在引用前必须先初始化，另外声明中符号“&amp;”的位置无关紧要，比如 int&amp; a＝x； 、int &amp;<br>a＝x； 和 int &amp;a＝x； 等效。<br>例：</p>
<p>……</p>
<p>int x＝56； //定义并初始化 x</p>
<p>int &amp; a＝x； //声明 a 是 x 的引用，二者地址相同</p>
<p>int &amp;r＝a； //声明 r 是 a 的引用，二者地址相同</p>
<p>……</p>
<p>r＝25； //改变 r，则 a 和 x 都同步变化</p>
<p>……</p>
<p>==<strong>面向过程的优点和缺点:</strong>==</p>
<p>缺点：代码的复用性（写过一遍再写一遍）极差，编写难度大。</p>
<p>好处：运行速度快。</p>
<p>==<strong>面向对象的好处和缺点：</strong>==</p>
<p>缺点：占用资源会变多，计算量大。</p>
<p>好处：复用性高。</p>
<p>==<strong>运算符重载中 加号在前面和后面的区别？</strong>==</p>
<p>Cpp编辑器可以通过在运算符函数参数表中是否插入关键字int来区分这两种方式</p>
<p>声明：</p>
<p>X operator++();//前缀方式</p>
<p>X operator++(int);//后缀方式</p>
<p>调用时，参数int一般传递给值0</p>
<p>X ob;</p>
<p>++ob;</p>
<p>ob++;//隐式调用ob.operator++(int)</p>
<p>ob.operator++();</p>
<p>ob.operator++(0);//显式调用ob.operator++(int)，意为ob++</p>
<p>==<strong>new和malloc的区别？</strong>==</p>
<p>new一个对象,自动分配大小,并且自动调用构造函数。New可以被重载。有的时候你会看到new[]，这些都能重载，比如你人为定义的datastructure，线性表什么的。delete []只能对数组。</p>
<p>malloc是系统方法需要手动分配内存，不能重载，不会自动执行构造函数</p>
<p>==<strong>c语言中和str相关的几个函数？</strong>==</p>
<p>Strcmp:C/C++函数，比较两个字符串</p>
<p>设这两个字符串为str1，str2，</p>
<p>若str1==str2，则返回零;</p>
<p>若str1&lt;str2，则返回负数;</p>
<p>若str1&gt;str2，则返回正数。</p>
<p>matlab中函数，strcmp(s1，s2)</p>
<p>判断两个字符串s1和s2是否相同，相同返回true ,不同返回false</p>
<p>Strcat:是用来连接两个字符串的，原型是char <em>strcat(char </em>dest,char *src)，作用是把src所指字符串添加到dest结尾处。</p>
<p>Strcopy：把从后面地址开始且含有NULL结束符的字符串复制到以前面开始的地址空间</p>
<p>指针、地址和引用的区别？<br>取指针是* ，地址和引用是与号</p>
<p>指针：指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元。</p>
<p>引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已，在函数传参的时候用到。</p>
<p>==<strong>面向过程的程序设计</strong>==</p>
<pre><code>- 传统的设计方法，围绕功能进行；
- 用一个函数实现一个功能；
- 所有的数据都是公用的；
- 一个函数可以使用任何
  一组数据；
- 一组数据又能被多个函
  数所使用。  
</code></pre><p><strong>==面向对象的程序设计==</strong></p>
<pre><code>-围绕现实世界的实体（对象）进行设计；

-程序设计者从设计函数功能转向：设计类与对象（如何用属性和行为来描述一个实体）；如何向实体发送消息以调度实体的行为。

- 一种以认识认识世界的方法为参考的程序设计方法，更为自然，更利于大型程序的组织和实现。
</code></pre><p>==<strong>类的概念</strong>==</p>
<p>++Def++：类是对一群具有相同属性(特征/数据)，表现相同行为的对象的描述。→抽象</p>
<p>++类的封装++：将属性（数据）和行为（操作代码）放在一起，形成一个基本的单位，对外保留访问接口，隐藏数据。比如，pool的操作对外公开可访问，数据部分隐藏。</p>
<p>++类的继承++：与客观的世界相仿，类可以作为父亲（父类/基类）派生出子类（派生类）。子类可以从父类那里继承东西（数据和操作）。比如,马类可派生出白马类和黑马类，pool可作为父类派生出圆游泳池类和方游泳池类。</p>
<p>==<strong>类的声明</strong>==</p>
<p>class  类名{</p>
<pre><code>public:
   公有数据和函数
private:
   私有数据和函数
</code></pre><p>};</p>
<p>==<strong>数据成员的声明:</strong>==</p>
<ul>
<li>像声明普通变量的方式来声明，但不允许声明时初始化；</li>
<li>允许是任何数据类型, 包括用户自定义的类型(不允许是当前正在定义的类型)；</li>
<li>声明时可以用static修饰，可以用const修饰；不允许使用auto,register和extern修饰。</li>
</ul>
<p>==<strong>成员函数的声明:</strong>==</p>
<ul>
<li><p>普通函数：非成员函数，即类外定义的函数。<br>大部分成员函数可像声明普通函数的方式在类内声明，可以使用const修饰。</p>
</li>
<li><p>常量成员函数：常量成员函数可以改变局部变量，全局变量或其他类对象的值，但不允许修改本类中的数据成员的值。<br>普通函数不可以作为常量函数（不能用const修饰）</p>
</li>
</ul>
<p>类内会有一些<strong>特殊的成员函数声明方式</strong>跟普通函数不同：</p>
<ul>
<li><p>构造函数-负责对象的初始化</p>
</li>
<li><p>拷贝构造函数-负责对象的拷贝初始化</p>
</li>
<li><p>析构函数-负责对象的撤销</p>
</li>
</ul>
<p>==<strong>类的使用</strong>==</p>
<p>类类型是一种用户自定义类型，程序员可以使用这个新类型在程序中声明变量，具有类类型的变量称为对象。</p>
<p>pool apool;</p>
<p>X x1,x2,x3;</p>
<p>可以使用sizeof()验证对象所占用的空间大小。</p>
<p>==<strong>类的访问控制</strong>==</p>
<p>规定类的成员(数据成员和成员函数)对外部的开放程度。</p>
<p>public：可以让本类内成员和其他程序代码使用的部分放在公有访问控制内。–类的对外接口</p>
<pre><code>在声明了一个类以后，用户主要是通过调用公用的成员函数来实现类提供的功能(例如对数据成员设置值，显示数据成员的值，对数据进行加工等)。
</code></pre><p>private：只允许本类内成员使用的部分放在私有访问控制内。–类的对外隐藏</p>
<p>protected：允许继承体系中的类成员访问的部分放在受保护访问控制内</p>
<p>==<strong>类与对象的关系</strong>==</p>
<p>每一个实体都是对象。有一些对象是具有相同的结构和特性的。每个对象都属于一个特定的类型。类是关于一组结构与行为相似的对象的共同特性的描述。</p>
<p>在Cpp中对象的类型称为类(class)。类代表了某一批对象的共性和特征。即：类是对象的抽象，而对象是类的具体实例(instance)。</p>
<p>在Cpp程序中，类是面向对象程序静态文本的概念，而对象是面向对象程序动态运行时的概念。</p>
<p>==<strong>对象的使用(在类外使用公有成员)</strong>==：</p>
<p>通过对象名和成员运算符访问对象中的成员</p>
<pre><code>apool.build();
</code></pre><p>通过指向对象的指针访问对象中的成员</p>
<pre><code>pool *ptr=&amp;apool;
ptr-&gt;build();
(*ptr).build();
★类内的隐含对象指针this：
  所有在类内使用类成员的行为都是通过this进行。
  this可以省略。
</code></pre><p>==<strong>如何设计类？</strong>==</p>
<p>Eg：停车场收费：有一个停车场，需要替管理员设计一个程序来解决停车收费的问题。</p>
<p>1小时内免费；</p>
<p>1小时以上：</p>
<pre><code>超过15分钟不到30分钟按半小时收费； 
超过30分钟不到1小时按1小时收费；
超过1小时按每小时4元收费；
</code></pre><p>从应用的需求出发，面向对象的分析：</p>
<p>停车场: 位置,大小(可以停几辆车),收费标准,几个管理员……</p>
<p>管理员: 性别,年龄,籍贯,身高,体重,受教育程度,……<br>汽车: 品牌,颜色,轮子个数,……</p>
<p>时钟/时间: 品牌,是否正常工作,时,分,秒,……</p>
<p>++对一个为管理员设计的收费系统，哪个对象是需要关注的？++</p>
<p>时间+收费标准</p>
<p>++如何设计时钟类？++</p>
<p>·要如何使用时钟？</p>
<p>   有车进入停车场的时候看一下时钟登记；</p>
<p>   有车离开停车场的时候看一下时钟登记；</p>
<p>   →计算停车时间，结合收费标准收费。</p>
<p>·时钟是什么样的？→模拟数字时钟 </p>
<p>有：时，分，秒   (hh:mm:ss)</p>
<p>可以：显示时间<br>           设置时间→调整时间(调整时，调整分，调整秒)</p>
<p>==<strong>类的实例（考虑下列类的定义）</strong>==</p>
<p>1.循环计数器类</p>
<ol start="2">
<li>date类</li>
</ol>
<p>3.平面几何的位置类position</p>
<p>4.复数类</p>
</div><div class="tags"></div><div class="article-footer"><a class="excerpt-link" href="/2019/03/02/hello-world/">全文...</a><div class="article-footer__right"><span class="date">写于2019年03月02日</span></div></div></section></div><div id="backToTop"><div class="back-arrow back-arrow-left"></div><div class="back-arrow back-arrow-right"></div></div><footer class="container"><div class="rights"><span>Powered by </span><a href="http://hexo.io" target="_blank">Hexo</a><span>, Theme </span><a href="https://github.com/gary-Shen/hexo-theme-curry" target="_blank">Curry</a><span>.</span></div></footer><script src="/script/jquery.min.js"></script><link rel="stylesheet" href="/fancybox/jquery.fancybox.css"><script src="/fancybox/jquery.fancybox.pack.js"></script><script src="/script/index.js"></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-61220413-1', 'auto');
ga('send', 'pageview');</script></body></html>